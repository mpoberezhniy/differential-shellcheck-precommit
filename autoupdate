#!/bin/bash
# This script automatically creates commits and tags for each Docker version
export DOCKERHOST="ghcr.io"
export DOCKERHUB="mpoberezhniy/differential-shellcheck-precommit"
commit_message="Differential ShellCheck \$VERSION"


info() {
  # shellcheck disable=SC2059
  printf >&2 "$1\\n" "${@:2}"
}

die() {
  info "$@"
  exit 1
}

should_regenerate=0

for arg
do
  case "$arg" in
    --regenerate-all) should_regenerate=1 ;;
    *)
      die "Unknown option: %s" "$arg"
      exit 1
      ;;
  esac
done

has_tag() {
  git rev-parse "$1" > /dev/null 2>&1
}

make_tag() {
  if has_tag "$VERSION"
  then
    if (( should_regenerate ))
    then
      info "Deleting existing tag %s, but leaving commit alone." "$VERSION"
      git tag -d "$VERSION" || die "Failed to delete tag"
    else
      info "Skipping existing tag %s" "$VERSION"
      return 0
    fi
  fi

  {
    echo "# This file was autogenerated, see pre-commit-hooks.yaml.template and autoupdate"
    envsubst < "pre-commit-hooks.yaml.template"
  } > ".pre-commit-hooks.yaml" || die "Failed to fill in hook template"

  envsubst < "README.md.template" > "README.md" ||
      die "Failed to fill in README template"

  envsubst < "Dockerfile.template" > "Dockerfile" ||
      die "Failed to fill in Dockerfile template"

  git add .pre-commit-hooks.yaml README.md Dockerfile
  git commit -a -m "$(envsubst <<< "$commit_message")" ||
      die "Failed to commit"

  git tag "$VERSION" ||
      die "Failed to tag"
}

fetch_tags() {
  curl "https://api.github.com/repos/redhat-plumbers-in-action/differential-shellcheck/tags" |
    jq -r '.[].name' |
    grep '^v' |
    sort -V
}

is_supported_version() {
  [[ $# -lt 1 ]] && return 1
  local version
  IFS=$'\n'
  read -d '' -r -a version <<< "$(echo "$1" | grep -oP '[0-9]+')"
  local min_supported_version=(5 2 0)

  # iterate over the version to support sliding tags e.g. v5
  for (( i = 0; i < ${#version[@]}; i++ ))
  do
    if (( 10#${version[i]} > 10#${min_supported_version[i]} )); then
      return 0
    elif (( 10#${version[i]} < 10#${min_supported_version[i]} )); then
      return 1
    fi
  done
  return 0
}


while read -r version
do
  if is_supported_version "$version"
  then
    export VERSION="$version"
    make_tag
  fi
done < <(fetch_tags)


latest=$(git describe HEAD --tags --abbrev=0) ||
    die "git describe failed"

info "Done: the latest version is %s" "$latest"
